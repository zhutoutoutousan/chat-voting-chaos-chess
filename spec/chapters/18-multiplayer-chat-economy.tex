\chapter{Multiplayer, Chat Rooms, and Platform Economy}

\section{Overview}

This chapter details the comprehensive multiplayer features, dedicated chat room system, and platform economy that enable social interaction, community building, and economic engagement beyond individual games.

\section{Multiplayer Features}

\subsection{Game Modes}

\subsubsection{One-on-One Games}

Traditional two-player chess games:

\begin{itemize}
    \item \textbf{Direct Challenge}: Invite specific players
    \item \textbf{Matchmaking}: Automatic pairing by rating
    \item \textbf{Quick Match}: Instant game matching
    \item \textbf{Custom Games}: Set time controls and rules
\end{itemize}

\subsubsection{Simultaneous Games}

Players can participate in multiple games simultaneously:

\begin{itemize}
    \item \textbf{Game Limits}: Maximum concurrent games per user
    \begin{itemize}
        \item Free: 3 simultaneous games
        \item Premium: 10 simultaneous games
        \item Diamond: Unlimited games
    \end{itemize}
    \item \textbf{Game Management}: Dashboard to manage all active games
    \item \textbf{Notifications}: Alerts when it's your turn in any game
    \item \textbf{Priority System}: Mark games as high/low priority
\end{itemize}

\subsubsection{Spectator Mode}

\begin{itemize}
    \item \textbf{Public Games}: Watch any public game in real-time
    \item \textbf{Private Spectating}: Invite-only spectator access
    \item \textbf{Spectator Count}: Display number of viewers
    \item \textbf{Commentary}: Spectators can comment on moves
    \item \textbf{Analysis View}: See engine evaluations (if enabled)
    \item \textbf{Replay Controls}: Pause, rewind, fast-forward
\end{itemize}

\subsubsection{Team Chess}

Multiplayer team-based gameplay:

\begin{itemize}
    \item \textbf{Team Formation}: Create or join teams
    \item \textbf{Team Matches}: Team vs team games
    \item \textbf{Consultation Mode}: Team members discuss moves
    \item \textbf{Team Rating}: Separate team ELO rating
    \item \textbf{Team Tournaments}: Team-based competitions
\end{itemize}

\subsection{Matchmaking System}

\subsubsection{Rating-Based Matching}

\begin{lstlisting}[language=typescript, caption=Rating-Based Matchmaking]
interface MatchmakingRequest {
    userId: string;
    ratingType: RatingType;
    timeControl: string;
    isRated: boolean;
    maxRatingDiff: number; // Maximum rating difference
}

class MatchmakingService {
    private queues: Map<string, Queue<MatchmakingRequest>> = new Map();
    
    async joinQueue(request: MatchmakingRequest): Promise<void> {
        const queueKey = this.getQueueKey(request);
        
        if (!this.queues.has(queueKey)) {
            this.queues.set(queueKey, new Queue());
        }
        
        const queue = this.queues.get(queueKey)!;
        
        // Check for compatible opponent
        const opponent = queue.find(opp => 
            Math.abs(opp.rating - request.rating) <= request.maxRatingDiff
        );
        
        if (opponent) {
            // Create game
            await this.createGame(request, opponent);
            queue.remove(opponent);
        } else {
            // Add to queue
            queue.enqueue(request);
        }
    }
    
    private getQueueKey(request: MatchmakingRequest): string {
        return `${request.ratingType}-${request.timeControl}-${request.isRated}`;
    }
}
\end{lstlisting}

\subsubsection{Matchmaking Algorithms}

\begin{itemize}
    \item \textbf{Rating Proximity}: Match players with similar ratings
    \item \textbf{Time Control Matching}: Match preferred time controls
    \item \textbf{Queue Time}: Expand search range over time
    \item \textbf{Connection Quality}: Consider ping/latency
    \item \textbf{Behavioral Matching}: Avoid repeat opponents (optional)
\end{itemize}

\subsection{Game Lobbies}

\subsubsection{Lobby Types}

\begin{itemize}
    \item \textbf{Public Lobbies}: Open to all players
    \item \textbf{Private Lobbies}: Invite-only
    \item \textbf{Rated Lobbies}: Games affect ratings
    \item \textbf{Casual Lobbies}: No rating impact
    \item \textbf{Chaos Lobbies}: Chaos mode enabled
\end{itemize}

\subsubsection{Lobby Features}

\begin{lstlisting}[language=typescript, caption=Game Lobby Model]
model GameLobby {
  id              String   @id @default(cuid())
  name            String
  description     String?
  hostId          String
  host            User     @relation(fields: [hostId], references: [id])
  
  // Settings
  timeControl     String
  isRated         Boolean   @default(false)
  isChaosMode     Boolean   @default(false)
  maxPlayers      Int       @default(2)
  isPublic        Boolean   @default(true)
  password        String?   // For private lobbies
  
  // Participants
  players         LobbyPlayer[]
  spectators      LobbySpectator[]
  
  // Status
  status          LobbyStatus @default(WAITING)
  currentGameId   String?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([hostId])
  @@index([status])
}

model LobbyPlayer {
  id          String   @id @default(cuid())
  lobbyId     String
  lobby       GameLobby @relation(fields: [lobbyId], references: [id], onDelete: Cascade)
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  isReady     Boolean  @default(false)
  joinedAt    DateTime @default(now())
  
  @@unique([lobbyId, userId])
  @@index([userId])
}
\end{lstlisting}

\section{Chat Room System}

\subsection{Chat Room Types}

\subsubsection{Global Chat Rooms}

Platform-wide chat rooms:

\begin{itemize}
    \item \textbf{General}: Main community chat
    \item \textbf{New Players}: Welcome room for beginners
    \item \textbf{Help \& Support}: Technical assistance
    \item \textbf{Off-Topic}: Non-chess discussions
    \item \textbf{Regional Rooms}: Language/region-specific
\end{itemize}

\subsubsection{Game-Specific Chat}

\begin{itemize}
    \item \textbf{In-Game Chat}: Chat during active games
    \item \textbf{Post-Game Chat}: Discussion after game ends
    \item \textbf{Analysis Chat}: Discuss game analysis
\end{itemize}

\subsubsection{Club Chat Rooms}

\begin{itemize}
    \item \textbf{Club Main}: Primary club discussion
    \item \textbf{Club Events}: Tournament and event discussions
    \item \textbf{Club Training}: Learning and practice discussions
\end{itemize}

\subsubsection{Private Chat Rooms}

\begin{itemize}
    \item \textbf{Direct Messages}: One-on-one conversations
    \item \textbf{Group Chats}: Multi-user private rooms
    \item \textbf{Temporary Rooms}: Auto-delete after inactivity
\end{itemize}

\subsection{Chat Room Architecture}

\subsubsection{Database Schema}

\begin{lstlisting}[language=prisma, caption=Chat Room Models]
model ChatRoom {
  id              String   @id @default(cuid())
  name            String
  description     String?
  type            ChatRoomType
  isPublic        Boolean  @default(true)
  password        String?  // For private rooms
  maxMembers      Int?
  
  // Ownership
  ownerId         String?
  owner           User?    @relation("OwnedRooms", fields: [ownerId], references: [id])
  
  // Relationships
  members         ChatRoomMember[]
  messages        ChatRoomMessage[]
  moderators      ChatRoomModerator[]
  
  // Settings
  settings        Json?    // Room-specific settings
  isArchived      Boolean  @default(false)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([type])
  @@index([isPublic])
}

model ChatRoomMember {
  id          String   @id @default(cuid())
  roomId      String
  room        ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  role        ChatRoomRole @default(MEMBER)
  joinedAt    DateTime @default(now())
  lastReadAt  DateTime @default(now())
  
  @@unique([roomId, userId])
  @@index([userId])
}

model ChatRoomMessage {
  id          String   @id @default(cuid())
  roomId      String
  room        ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  
  message     String
  messageType MessageType @default(TEXT)
  
  // Rich content
  attachments Json?    // Images, files, etc.
  reactions   MessageReaction[]
  
  // Moderation
  isDeleted   Boolean  @default(false)
  deletedAt   DateTime?
  deletedBy   String?
  
  timestamp   DateTime @default(now())
  editedAt    DateTime?
  
  @@index([roomId, timestamp])
  @@index([userId])
}

enum ChatRoomType {
  GLOBAL
  GAME
  CLUB
  PRIVATE
  GROUP
}

enum ChatRoomRole {
  MEMBER
  MODERATOR
  ADMIN
  OWNER
}
\end{lstlisting}

\subsubsection{WebSocket Implementation}

\begin{lstlisting}[language=typescript, caption=Chat Room Gateway]
@WebSocketGateway({
  namespace: '/chat-rooms',
})
export class ChatRoomGateway {
  @WebSocketServer()
  server: Server;
  
  @SubscribeMessage('join-room')
  async handleJoinRoom(
    @MessageBody() data: { roomId: string },
    @ConnectedSocket() client: Socket,
  ) {
    const { roomId } = data;
    const userId = client.data.userId;
    
    // Verify user has access
    const hasAccess = await this.chatRoomService.hasAccess(roomId, userId);
    if (!hasAccess) {
      client.emit('error', { message: 'Access denied' });
      return;
    }
    
    // Join socket room
    client.join(`room:${roomId}`);
    
    // Add to room members if not already
    await this.chatRoomService.addMember(roomId, userId);
    
    // Notify others
    client.to(`room:${roomId}`).emit('user-joined', {
      userId,
      username: client.data.username,
      timestamp: new Date(),
    });
    
    // Send recent messages
    const messages = await this.chatRoomService.getRecentMessages(roomId, 50);
    client.emit('room-history', { messages });
  }
  
  @SubscribeMessage('send-message')
  async handleSendMessage(
    @MessageBody() data: { roomId: string; message: string },
    @ConnectedSocket() client: Socket,
  ) {
    const { roomId, message } = data;
    const userId = client.data.userId;
    
    // Check rate limiting
    const canSend = await this.chatRoomService.checkRateLimit(roomId, userId);
    if (!canSend) {
      client.emit('error', { message: 'Rate limit exceeded' });
      return;
    }
    
    // Save message
    const chatMessage = await this.chatRoomService.createMessage({
      roomId,
      userId,
      message,
    });
    
    // Broadcast to room
    this.server.to(`room:${roomId}`).emit('new-message', {
      id: chatMessage.id,
      userId,
      username: chatMessage.user.username,
      message: chatMessage.message,
      timestamp: chatMessage.timestamp,
    });
  }
  
  @SubscribeMessage('leave-room')
  async handleLeaveRoom(
    @MessageBody() data: { roomId: string },
    @ConnectedSocket() client: Socket,
  ) {
    const { roomId } = data;
    client.leave(`room:${roomId}`);
    
    client.to(`room:${roomId}`).emit('user-left', {
      userId: client.data.userId,
      timestamp: new Date(),
    });
  }
}
\end{lstlisting}

\subsection{Chat Features}

\subsubsection{Message Features}

\begin{itemize}
    \item \textbf{Text Messages}: Standard text communication
    \item \textbf{Emojis}: Unicode and custom chess emojis
    \item \textbf{Mentions}: @username mentions with notifications
    \item \textbf{Reactions}: React to messages with emojis
    \item \textbf{Message Editing}: Edit messages within time limit
    \item \textbf{Message Deletion}: Delete own messages
    \item \textbf{File Attachments}: Images, PGN files, etc.
    \item \textbf{Chess Notation}: Auto-format chess moves
    \item \textbf{Link Previews}: Rich previews for URLs
\end{itemize}

\subsubsection{Moderation}

\begin{itemize}
    \item \textbf{Automated Filtering}: Filter inappropriate content
    \item \textbf{User Reports}: Report messages or users
    \item \textbf{Moderator Actions}: Mute, ban, warn users
    \item \textbf{Slow Mode}: Limit message frequency
    \item \textbf{Word Filters}: Block specific words/phrases
    \item \textbf{Spam Detection}: Automatic spam filtering
\end{itemize}

\section{Platform Economy}

\subsection{Virtual Currency System}

\subsubsection{Currency Types}

\begin{itemize}
    \item \textbf{Chess Coins}: Primary virtual currency
    \item \textbf{Chess Gems}: Premium currency (purchasable)
    \item \textbf{Chess Points}: Earned through gameplay
\end{itemize}

\subsubsection{Currency Earning}

\begin{lstlisting}[language=typescript, caption=Currency Earning System]
interface CurrencyReward {
    action: string;
    amount: number;
    currencyType: 'coins' | 'gems' | 'points';
}

const EARNING_RULES: CurrencyReward[] = [
    { action: 'game_win', amount: 50, currencyType: 'coins' },
    { action: 'game_draw', amount: 25, currencyType: 'coins' },
    { action: 'game_loss', amount: 10, currencyType: 'coins' },
    { action: 'daily_login', amount: 20, currencyType: 'coins' },
    { action: 'puzzle_solve', amount: 5, currencyType: 'coins' },
    { action: 'lesson_complete', amount: 15, currencyType: 'coins' },
    { action: 'tournament_win', amount: 500, currencyType: 'coins' },
    { action: 'rating_milestone', amount: 100, currencyType: 'coins' },
    { action: 'streak_bonus', amount: 50, currencyType: 'coins' },
];

class CurrencyService {
    async awardCurrency(
        userId: string,
        action: string,
        metadata?: any
    ): Promise<void> {
        const rule = EARNING_RULES.find(r => r.action === action);
        if (!rule) return;
        
        // Calculate bonus multipliers
        const multiplier = await this.calculateMultiplier(userId, action, metadata);
        const amount = Math.floor(rule.amount * multiplier);
        
        await this.addCurrency(userId, rule.currencyType, amount);
        
        // Log transaction
        await this.logTransaction({
            userId,
            type: 'earn',
            currencyType: rule.currencyType,
            amount,
            action,
            metadata,
        });
    }
    
    private async calculateMultiplier(
        userId: string,
        action: string,
        metadata?: any
    ): Promise<number> {
        let multiplier = 1.0;
        
        // Premium bonus
        const user = await this.getUser(userId);
        if (user.isPremium) {
            multiplier += 0.2; // 20% bonus
        }
        
        // Streak bonus
        const streak = await this.getStreak(userId);
        if (streak >= 7) {
            multiplier += 0.1; // 10% bonus for 7+ day streak
        }
        
        // Weekend bonus
        if (this.isWeekend()) {
            multiplier += 0.15; // 15% weekend bonus
        }
        
        return multiplier;
    }
}
\end{lstlisting}

\subsubsection{Currency Spending}

\begin{itemize}
    \item \textbf{Academy Courses}: Purchase premium courses
    \item \textbf{Chess Themes}: Custom board/piece themes
    \item \textbf{Avatars}: Custom profile avatars
    \item \textbf{Emotes}: Special chat emotes
    \item \textbf{Analysis}: Pay for additional engine analysis
    \item \textbf{Tournament Entry}: Enter paid tournaments
    \item \textbf{Time Extensions}: Buy extra time in games
    \item \textbf{Gift Items}: Send gifts to other players
\end{itemize}

\subsection{Marketplace}

\subsubsection{Digital Goods}

\begin{lstlisting}[language=prisma, caption=Marketplace Models]
model MarketplaceItem {
  id              String   @id @default(cuid())
  name            String
  description     String?
  category        ItemCategory
  type            ItemType
  
  // Pricing
  priceCoins      Int?
  priceGems       Int?
  priceUSD        Decimal?
  
  // Content
  content         Json     // Item-specific data (theme config, etc.)
  previewImage    String?
  
  // Availability
  isAvailable     Boolean  @default(true)
  isLimited       Boolean  @default(false)
  stockCount      Int?     // For limited items
  expiresAt       DateTime?
  
  // Creator
  creatorId       String?
  creator         User?    @relation(fields: [creatorId], references: [id])
  
  // Sales
  sales           MarketplaceSale[]
  reviews         MarketplaceReview[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([category])
  @@index([isAvailable])
}

model MarketplaceSale {
  id          String   @id @default(cuid())
  itemId      String
  item        MarketplaceItem @relation(fields: [itemId], references: [id])
  buyerId     String
  buyer       User     @relation(fields: [buyerId], references: [id])
  
  paymentType PaymentType
  amount      Decimal
  
  createdAt   DateTime @default(now())
  
  @@index([buyerId])
  @@index([itemId])
}

enum ItemCategory {
  THEME
  AVATAR
  EMOTE
  COURSE
  ANALYSIS
  TOURNAMENT
  OTHER
}

enum ItemType {
  CONSUMABLE    // One-time use
  PERMANENT     // Permanent ownership
  SUBSCRIPTION  // Time-limited
}
\end{lstlisting}

\subsubsection{User-Generated Content}

\begin{itemize}
    \item \textbf{Theme Creation}: Users can create and sell themes
    \item \textbf{Course Creation}: Create and sell academy courses
    \item \textbf{Revenue Sharing}: Creators earn percentage of sales
    \item \textbf{Quality Control}: Review process for user content
    \item \textbf{Rating System}: Rate and review marketplace items
\end{itemize}

\subsection{Economy API}

\subsubsection{Currency Management}

\begin{lstlisting}[language=typescript, caption=Currency API]
@Controller('economy')
@UseGuards(JwtAuthGuard)
export class EconomyController {
    constructor(
        private currencyService: CurrencyService,
        private marketplaceService: MarketplaceService
    ) {}
    
    @Get('balance')
    async getBalance(@Request() req) {
        return this.currencyService.getBalance(req.user.userId);
    }
    
    @Get('transactions')
    async getTransactions(
        @Request() req,
        @Query('limit') limit: number = 50,
        @Query('offset') offset: number = 0
    ) {
        return this.currencyService.getTransactions(
            req.user.userId,
            limit,
            offset
        );
    }
    
    @Post('purchase')
    async purchaseItem(
        @Request() req,
        @Body() body: { itemId: string; paymentType: 'coins' | 'gems' | 'usd' }
    ) {
        return this.marketplaceService.purchaseItem(
            req.user.userId,
            body.itemId,
            body.paymentType
        );
    }
    
    @Post('gift')
    async sendGift(
        @Request() req,
        @Body() body: { recipientId: string; itemId: string; message?: string }
    ) {
        return this.marketplaceService.sendGift(
            req.user.userId,
            body.recipientId,
            body.itemId,
            body.message
        );
    }
}
\end{lstlisting}

\subsection{Economy Features}

\subsubsection{Daily Rewards}

\begin{itemize}
    \item \textbf{Login Streak}: Consecutive daily logins increase rewards
    \item \textbf{Weekly Bonus}: Larger rewards for weekly completion
    \item \textbf{Monthly Rewards}: Special monthly bonuses
    \item \textbf{Event Rewards}: Limited-time event bonuses
\end{itemize}

\subsubsection{Achievement Rewards}

\begin{itemize}
    \item \textbf{Rating Milestones}: Rewards for reaching rating thresholds
    \item \textbf{Game Milestones}: Rewards for games played/won
    \item \textbf{Learning Milestones}: Rewards for academy progress
    \item \textbf{Social Milestones}: Rewards for social interactions
\end{itemize}

\subsubsection{Tournament Economy}

\begin{itemize}
    \item \textbf{Entry Fees}: Pay coins/gems to enter tournaments
    \item \textbf{Prize Pools}: Winners receive currency rewards
    \item \textbf{Sponsorship}: Premium users can sponsor tournaments
    \item \textbf{Betting}: Spectators can bet on games (if legal)
\end{itemize}

\section{Integration Points}

\subsection{Multiplayer-Chat Integration}

\begin{itemize}
    \item \textbf{Game Chat}: Automatic chat room for each game
    \item \textbf{Lobby Chat}: Chat in game lobbies
    \item \textbf{Team Chat}: Private chat for team members
    \item \textbf{Tournament Chat}: Chat rooms for tournaments
\end{itemize}

\subsection{Economy-Chat Integration}

\begin{itemize}
    \item \textbf{Chat Emotes}: Purchase and use premium emotes
    \item \textbf{Chat Themes}: Customize chat appearance
    \item \textbf{Chat Gifts}: Send currency/gifts via chat
    \item \textbf{Chat Rewards}: Earn currency for active chat participation
\end{itemize}

\subsection{Economy-Multiplayer Integration}

\begin{itemize}
    \item \textbf{Game Rewards}: Earn currency from games
    \item \textbf{Tournament Prizes}: Currency rewards for tournaments
    \item \textbf{Matchmaking Fees}: Optional fees for premium matchmaking
    \item \textbf{Spectator Rewards}: Earn currency for spectating
\end{itemize}

\section{Database Schema Extensions}

\subsubsection{Currency Models}

\begin{lstlisting}[language=prisma, caption=Currency Models]
model UserCurrency {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  coins       Int      @default(0)
  gems        Int      @default(0)
  points      Int      @default(0)
  
  updatedAt   DateTime @updatedAt
  
  @@unique([userId])
  @@index([userId])
}

model CurrencyTransaction {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  
  type        TransactionType
  currencyType CurrencyType
  amount      Int      // Positive for earning, negative for spending
  balance     Int      // Balance after transaction
  
  action      String?  // What triggered the transaction
  metadata    Json?    // Additional transaction data
  
  createdAt   DateTime @default(now())
  
  @@index([userId, createdAt])
  @@index([type])
}

enum TransactionType {
  EARN
  SPEND
  GIFT_SENT
  GIFT_RECEIVED
  REFUND
  PURCHASE
}

enum CurrencyType {
  COINS
  GEMS
  POINTS
}
\end{lstlisting}

\section{Analytics and Reporting}

\subsection{Economy Analytics}

\begin{itemize}
    \item \textbf{Currency Flow}: Track currency earning and spending
    \item \textbf{Popular Items}: Most purchased marketplace items
    \item \textbf{User Spending}: Individual user spending patterns
    \item \textbf{Revenue Metrics}: Platform revenue from marketplace
\end{itemize}

\subsection{Social Analytics}

\begin{itemize}
    \item \textbf{Chat Activity}: Messages per room, active users
    \item \textbf{Multiplayer Stats}: Concurrent games, matchmaking times
    \item \textbf{Community Growth}: New users, active users, retention
\end{itemize}

\section{Security Considerations}

\subsection{Economy Security}

\begin{itemize}
    \item \textbf{Transaction Validation}: Verify all currency transactions
    \item \textbf{Fraud Detection}: Detect suspicious currency patterns
    \item \textbf{Rate Limiting}: Prevent currency farming
    \item \textbf{Audit Logging}: Complete transaction history
\end{itemize}

\subsection{Chat Security}

\begin{itemize}
    \item \textbf{Message Encryption}: Encrypt sensitive messages
    \item \textbf{Spam Prevention}: Rate limiting and filtering
    \item \textbf{Content Moderation}: Automated and manual moderation
    \item \textbf{Privacy Controls}: User privacy settings
\end{itemize}

\section{Conclusion}

The integration of comprehensive multiplayer features, dedicated chat room system, and platform economy creates a vibrant, engaging community platform. These systems work together to:

\begin{itemize}
    \item Foster social connections through chat and multiplayer
    \item Provide economic incentives for engagement
    \item Enable user-generated content and marketplace
    \item Create sustainable revenue streams
    \item Build a thriving chess community
\end{itemize}
