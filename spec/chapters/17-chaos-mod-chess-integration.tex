\chapter{Chaos Mod Integration: From GTA to Chess}

\section{Overview}

This chapter describes how the chat voting chaos mod system, originally developed for Grand Theft Auto V, can be adapted and integrated into the Chat Voting Chaos Chess platform. The system allows spectators to vote on chess moves, creating an interactive and unpredictable gameplay experience.

\section{GTA Chaos Mod Architecture}

\subsection{System Components}

The GTA Chaos Mod (WebChaosModV) consists of three main components:

\begin{enumerate}
    \item \textbf{Chaos Mod}: The game modification that applies effects in GTA V
    \item \textbf{Twitch Chat Voting Proxy}: Middleware that connects chat to the game mod
    \item \textbf{Overlay Server}: Displays voting options and results to viewers
\end{enumerate}

\subsection{Communication Architecture}

The system uses a named pipe for inter-process communication:

\begin{lstlisting}[language=csharp, caption=Chaos Pipe Communication]
// Named pipe connection
NamedPipeClientStream pipe = new NamedPipeClientStream(
    ".",
    "ChaosModVTwitchChatPipe",
    PipeDirection.InOut,
    PipeOptions.Asynchronous
);
\end{lstlisting}

\subsection{Voting Flow}

The voting process follows these steps:

\begin{enumerate}
    \item \textbf{Vote Initiation}: Game mod sends vote options via pipe
    \item \textbf{Option Display}: Options are displayed to chat viewers
    \item \textbf{Vote Collection}: Chat messages are parsed for votes
    \item \textbf{Vote Aggregation}: Votes are counted and tracked
    \item \textbf{Result Calculation}: Winning option is determined
    \item \textbf{Effect Application}: Selected option is applied in-game
\end{enumerate}

\section{Voting Modes}

\subsection{Majority Voting}

In majority mode, the option with the most votes wins:

\begin{lstlisting}[language=csharp, caption=Majority Vote Calculation]
private int GetVoteResultByMajority()
{
    // Find the highest vote count
    var highestVoteCount = activeVoteOptions.Max(_ => _.Votes);
    // Get all options with highest vote count
    var chosenOptions = activeVoteOptions
        .FindAll(_ => _.Votes == highestVoteCount);
    
    // If tie, choose randomly
    if (chosenOptions.Count > 1) {
        return random.Next(0, chosenOptions.Count);
    }
    
    return activeVoteOptions.IndexOf(chosenOptions[0]);
}
\end{lstlisting}

\subsection{Percentage Voting}

In percentage mode, votes determine the probability of selection:

\begin{lstlisting}[language=csharp, caption=Percentage Vote Calculation]
private int GetVoteResultByPercentage()
{
    // Calculate total votes
    var totalVotes = activeVoteOptions.Sum(_ => _.Votes);
    
    // Select random vote within total range
    var selectedVote = random.Next(1, totalVotes + 1);
    
    // Find which option range contains the selected vote
    var voteRange = 0;
    for (var i = 0; i < activeVoteOptions.Count; i++) {
        voteRange += activeVoteOptions[i].Votes;
        if (selectedVote <= voteRange) {
            return i;
        }
    }
    
    return 0;
}
\end{lstlisting}

\subsection{Vote Tracking}

The system tracks individual user votes to prevent duplicate voting and allow vote changes:

\begin{lstlisting}[language=csharp, caption=Vote Tracking]
private Dictionary<string, int> userVotedFor = new Dictionary<string, int>();

// When user votes
if (!userVotedFor.TryGetValue(e.ClientId, out previousVote)) {
    // New vote
    userVotedFor.Add(e.ClientId, i);
    voteOption.Votes++;
} else if (previousVote != i) {
    // Change vote: remove old, add new
    activeVoteOptions[previousVote].Votes--;
    userVotedFor[e.ClientId] = i;
    voteOption.Votes++;
}
\end{lstlisting}

\section{Adaptation to Chess}

\subsection{Core Differences}

While the GTA mod applies random effects, chess chaos mode applies moves:

\begin{itemize}
    \item \textbf{GTA}: Random effects (spawn vehicle, change weather, etc.)
    \item \textbf{Chess}: Legal chess moves that affect game state
    \item \textbf{GTA}: Effects are independent actions
    \item \textbf{Chess}: Moves must be legal and sequential
\end{itemize}

\subsection{Move Generation}

Instead of random effects, the chess system generates legal move options:

\begin{lstlisting}[language=typescript, caption=Move Option Generation]
async function generateMoveOptions(gameId: string): Promise<MoveOption[]> {
    const game = await getGame(gameId);
    const legalMoves = await chessEngine.getLegalMoves(game.currentFen);
    
    // Select top N moves by engine evaluation
    const topMoves = legalMoves
        .map(move => ({
            move,
            evaluation: chessEngine.evaluateMove(game.currentFen, move)
        }))
        .sort((a, b) => b.evaluation - a.evaluation)
        .slice(0, 4); // Top 4 moves
    
    return topMoves.map((m, index) => ({
        id: index + 1,
        move: m.move,
        notation: m.move.toSAN(), // e.g., "e4", "Nf3"
        evaluation: m.evaluation,
        votes: 0
    }));
}
\end{lstlisting}

\section{Chess Notation Integration}

\subsection{Standard Algebraic Notation (SAN)}

Chess uses Standard Algebraic Notation to represent moves:

\begin{itemize}
    \item \textbf{Piece Notation}: K (King), Q (Queen), R (Rook), B (Bishop), N (Knight), P (Pawn - often omitted)
    \item \textbf{Square Notation}: Files (a-h) and ranks (1-8)
    \item \textbf{Move Examples}:
    \begin{itemize}
        \item \texttt{e4}: Pawn to e4
        \item \texttt{Nf3}: Knight to f3
        \item \texttt{Qxe5}: Queen captures on e5
        \item \texttt{O-O}: Kingside castling
        \item \texttt{e8=Q}: Pawn promotes to Queen on e8
    \end{itemize}
\end{itemize}

\subsection{Voting by Notation}

Spectators can vote using chess notation:

\begin{lstlisting}[language=typescript, caption=Notation-Based Voting]
function parseVoteMessage(message: string): string | null {
    // Remove whitespace and convert to lowercase
    const cleanMessage = message.trim().toLowerCase();
    
    // Pattern matching for chess notation
    const notationPatterns = [
        /^([a-h][1-8])$/,                    // e4, d5
        /^([nbrqk][a-h][1-8])$/,             // Nf3, Be5
        /^([nbrqk]x[a-h][1-8])$/,            // Nxe5, Bxf7
        /^([a-h]x[a-h][1-8])$/,              // exd5
        /^([a-h][1-8]=[nbrq])$/,              // e8=Q
        /^(o-o(-o)?)$/,                       // O-O, O-O-O
        /^([nbrqk][a-h]x[a-h][1-8])$/,       // Nxe5
        /^([nbrqk][1-8]x[a-h][1-8])$/,       // N5xe5 (disambiguation)
    ];
    
    for (const pattern of notationPatterns) {
        if (pattern.test(cleanMessage)) {
            return cleanMessage.toUpperCase();
        }
    }
    
    return null;
}
\end{lstlisting}

\subsection{Numeric Voting}

For simplicity, moves can also be voted by number:

\begin{itemize}
    \item \textbf{Option 1}: First suggested move (e.g., "e4")
    \item \textbf{Option 2}: Second suggested move (e.g., "Nf3")
    \item \textbf{Option 3}: Third suggested move (e.g., "d4")
    \item \textbf{Option 4}: Fourth suggested move (e.g., "c4")
\end{itemize}

\section{Chaos Effects on Chess Moves}

\subsection{Move Modification}

Chaos effects can modify moves in various ways:

\subsubsection{Move Inversion}

Invert the evaluation - choose the worst move instead of best:

\begin{lstlisting}[language=typescript, caption=Move Inversion Effect]
function applyInversionEffect(moves: MoveOption[]): MoveOption[] {
    return moves
        .map(m => ({ ...m, evaluation: -m.evaluation }))
        .sort((a, b) => b.evaluation - a.evaluation);
}
\end{lstlisting}

\subsubsection{Random Move Injection}

Add completely random legal moves to the options:

\begin{lstlisting}[language=typescript, caption=Random Move Injection]
function injectRandomMoves(
    legalMoves: string[],
    currentOptions: MoveOption[]
): MoveOption[] {
    const randomMoves = legalMoves
        .filter(m => !currentOptions.some(o => o.move === m))
        .sort(() => Math.random() - 0.5)
        .slice(0, 2);
    
    return [
        ...currentOptions,
        ...randomMoves.map((move, i) => ({
            id: currentOptions.length + i + 1,
            move,
            notation: move.toSAN(),
            evaluation: Math.random() * 200 - 100, // Random eval
            votes: 0
        }))
    ];
}
\end{lstlisting}

\subsubsection{Move Restriction}

Limit move options to specific piece types:

\begin{lstlisting}[language=typescript, caption=Move Restriction Effect]
function restrictToPieceType(
    moves: MoveOption[],
    pieceType: 'pawn' | 'knight' | 'bishop' | 'rook' | 'queen' | 'king'
): MoveOption[] {
    return moves.filter(move => {
        const piece = getPieceFromMove(move.move);
        return piece.type === pieceType;
    });
}
\end{lstlisting}

\subsection{Position Effects}

Chaos effects can also modify the game position:

\subsubsection{Time Manipulation}

Modify time remaining for players:

\begin{lstlisting}[language=typescript, caption=Time Manipulation]
function applyTimeEffect(
    game: Game,
    effect: 'add' | 'subtract' | 'swap',
    amount: number
): Game {
    switch (effect) {
        case 'add':
            game.whiteTimeLeft += amount;
            game.blackTimeLeft += amount;
            break;
        case 'subtract':
            game.whiteTimeLeft = Math.max(0, game.whiteTimeLeft - amount);
            game.blackTimeLeft = Math.max(0, game.blackTimeLeft - amount);
            break;
        case 'swap':
            [game.whiteTimeLeft, game.blackTimeLeft] = 
                [game.blackTimeLeft, game.whiteTimeLeft];
            break;
    }
    return game;
}
\end{lstlisting}

\subsubsection{Move Reversal}

Allow undoing the last move (if both players agree):

\begin{lstlisting}[language=typescript, caption=Move Reversal Effect]
async function applyMoveReversal(gameId: string): Promise<Game> {
    const game = await getGame(gameId);
    
    if (game.moves.length < 2) {
        throw new Error('Cannot reverse: not enough moves');
    }
    
    // Remove last two moves (one per player)
    const newMoves = game.moves.slice(0, -2);
    const previousFen = calculateFenFromMoves(newMoves);
    
    return await updateGame(gameId, {
        moves: newMoves,
        currentFen: previousFen,
        moveNumber: game.moveNumber - 2
    });
}
\end{lstlisting}

\section{Chess-Specific Voting Implementation}

\subsection{Vote Collection}

\begin{lstlisting}[language=typescript, caption=Chess Vote Collection]
class ChessVotingService {
    private activeVotes: Map<string, VoteRound> = new Map();
    
    async startVotingRound(gameId: string): Promise<VoteRound> {
        const game = await getGame(gameId);
        const moveOptions = await generateMoveOptions(gameId);
        
        const voteRound: VoteRound = {
            gameId,
            round: this.getNextRoundNumber(gameId),
            options: moveOptions,
            votes: new Map(),
            startTime: new Date(),
            endTime: new Date(Date.now() + 30000), // 30 seconds
            mode: 'MAJORITY'
        };
        
        this.activeVotes.set(gameId, voteRound);
        
        // Broadcast to WebSocket clients
        this.broadcastVoteStart(voteRound);
        
        return voteRound;
    }
    
    async submitVote(
        gameId: string,
        userId: string,
        vote: string | number
    ): Promise<void> {
        const voteRound = this.activeVotes.get(gameId);
        if (!voteRound || new Date() > voteRound.endTime) {
            throw new Error('Voting round not active');
        }
        
        // Parse vote (notation or number)
        const optionId = typeof vote === 'number' 
            ? vote 
            : this.findOptionByNotation(voteRound, vote);
        
        if (!optionId) {
            throw new Error('Invalid vote');
        }
        
        // Update vote
        const previousVote = voteRound.votes.get(userId);
        if (previousVote !== undefined) {
            voteRound.options[previousVote].votes--;
        }
        
        voteRound.votes.set(userId, optionId);
        voteRound.options[optionId].votes++;
        
        // Broadcast update
        this.broadcastVoteUpdate(voteRound);
    }
    
    async getVoteResult(gameId: string): Promise<string> {
        const voteRound = this.activeVotes.get(gameId);
        if (!voteRound) {
            throw new Error('No active voting round');
        }
        
        let winningOption: MoveOption;
        
        if (voteRound.mode === 'MAJORITY') {
            // Find option with most votes
            winningOption = voteRound.options.reduce((max, opt) =>
                opt.votes > max.votes ? opt : max
            );
        } else {
            // Percentage mode: weighted random selection
            const totalVotes = voteRound.options.reduce((sum, opt) => 
                sum + opt.votes, 0
            );
            const random = Math.random() * totalVotes;
            let cumulative = 0;
            
            for (const option of voteRound.options) {
                cumulative += option.votes;
                if (random <= cumulative) {
                    winningOption = option;
                    break;
                }
            }
        }
        
        return winningOption.move;
    }
}
\end{lstlisting}

\subsection{Move Validation}

All voted moves must be validated before execution:

\begin{lstlisting}[language=typescript, caption=Move Validation]
async function validateAndExecuteMove(
    gameId: string,
    move: string
): Promise<GameUpdate> {
    const game = await getGame(gameId);
    const chess = new Chess(game.currentFen);
    
    // Validate move is legal
    const legalMoves = chess.moves({ verbose: true });
    const isValid = legalMoves.some(m => 
        m.san === move || m.from + m.to === move
    );
    
    if (!isValid) {
        throw new Error(`Illegal move: ${move}`);
    }
    
    // Execute move
    chess.move(move);
    
    // Update game state
    return await updateGame(gameId, {
        currentFen: chess.fen(),
        moves: [...game.moves, {
            moveNumber: game.moveNumber + 1,
            move: move,
            san: chess.history({ verbose: true }).slice(-1)[0].san,
            fen: chess.fen(),
            isWhiteMove: !game.isWhiteMove,
            timestamp: new Date()
        }]
    });
}
\end{lstlisting}

\section{Game Description Language Integration}

\subsection{GDL Concepts for Chess}

Based on Game Description Language principles, chess moves can be represented as:

\begin{itemize}
    \item \textbf{Legal Moves}: \texttt{(legal white (move e2 e4))}
    \item \textbf{Move Execution}: \texttt{(does white (move e2 e4))}
    \item \textbf{State Update}: \texttt{(next (cell e4 wp))}
    \item \textbf{Terminal State}: \texttt{(terminal (checkmate black))}
\end{itemize}

\subsection{Chaos-Enhanced GDL}

Extend GDL to support chaos voting:

\begin{lstlisting}[language=prolog, caption=Chaos-Enhanced GDL]
;;; Chaos voting predicates
(<= (chaos-vote-active)
    (true (chaos-mode))
    (not terminal))

(<= (legal spectator (vote ?move))
    (chaos-vote-active)
    (legal ?player ?move))

(<= (legal spectator (vote-number ?n))
    (chaos-vote-active)
    (vote-option ?n ?move))

;;; Vote aggregation
(<= (vote-count ?move ?count)
    (chaos-vote-active)
    (count-votes ?move ?count))

(<= (winning-move ?move)
    (chaos-vote-active)
    (vote-count ?move ?count)
    (not (exists ?move2 
        (vote-count ?move2 ?count2)
        (> ?count2 ?count))))

;;; Move execution from votes
(<= (next (does ?player ?move))
    (winning-move ?move)
    (true (control ?player)))
\end{lstlisting}

\subsection{Notation Translation}

Convert between SAN notation and GDL format:

\begin{lstlisting}[language=typescript, caption=Notation Translation]
function sanToGDL(san: string, currentFen: string): string {
    const chess = new Chess(currentFen);
    const move = chess.move(san);
    
    if (!move) {
        throw new Error(`Invalid SAN: ${san}`);
    }
    
    // Convert to GDL format: (move from to)
    return `(move ${move.from} ${move.to})`;
}

function gdlToSAN(gdlMove: string, currentFen: string): string {
    // Parse GDL: (move e2 e4)
    const match = gdlMove.match(/\(move\s+(\w+)\s+(\w+)\)/);
    if (!match) {
        throw new Error(`Invalid GDL format: ${gdlMove}`);
    }
    
    const [, from, to] = match;
    const chess = new Chess(currentFen);
    const move = chess.move({ from, to });
    
    return move.san;
}
\end{lstlisting}

\section{Chaos Effects Taxonomy}

\subsection{Move Selection Effects}

\begin{itemize}
    \item \textbf{Engine Best}: Select top engine-recommended moves
    \item \textbf{Engine Worst}: Select worst engine moves
    \item \textbf{Random Legal}: Include random legal moves
    \item \textbf{Piece-Specific}: Restrict to specific piece types
    \item \textbf{Square-Specific}: Restrict to specific squares
\end{itemize}

\subsection{Game State Effects}

\begin{itemize}
    \item \textbf{Time Manipulation}: Add/subtract/swap time
    \item \textbf{Move Reversal}: Undo last move(s)
    \item \textbf{Position Swap}: Swap player positions
    \item \textbf{Material Change}: Add/remove pieces (if variant allows)
\end{itemize}

\subsection{Voting System Effects}

\begin{itemize}
    \item \textbf{Vote Weighting}: Premium users have higher vote weight
    \item \textbf{Vote Multiplier}: Certain conditions multiply votes
    \item \textbf{Vote Decay}: Votes decrease over time
    \item \textbf{Blind Voting}: Hide vote counts until end
\end{itemize}

\section{Implementation Architecture}

\subsection{System Components}

\begin{lstlisting}[language=typescript, caption=Chaos Chess Architecture]
// Backend: Nest.js Module
@Module({
    imports: [GamesModule, ChessModule],
    providers: [ChaosVotingService, MoveGeneratorService],
    controllers: [ChaosVotingController],
    exports: [ChaosVotingService]
})
export class ChaosVotingModule {}

// Service: Chaos Voting Logic
@Injectable()
export class ChaosVotingService {
    constructor(
        private gamesService: GamesService,
        private chessEngine: ChessEngineService,
        private websocketGateway: ChaosVotingGateway
    ) {}
    
    async startVotingRound(gameId: string): Promise<VoteRound> {
        // Implementation
    }
    
    async processVote(gameId: string, userId: string, vote: string): Promise<void> {
        // Implementation
    }
    
    async executeWinningMove(gameId: string): Promise<Game> {
        // Implementation
    }
}

// Gateway: WebSocket Communication
@WebSocketGateway({ namespace: '/chaos-voting' })
export class ChaosVotingGateway {
    @WebSocketServer()
    server: Server;
    
    // Broadcast vote updates
    // Handle vote submissions
    // Notify move execution
}
\end{lstlisting}

\section{User Experience Flow}

\subsection{Spectator Flow}

\begin{enumerate}
    \item Join game as spectator
    \item View current position and legal moves
    \item See voting options (moves with notation)
    \item Submit vote via chat or UI
    \item See real-time vote counts
    \item Watch winning move execute
    \item Repeat for next move
\end{enumerate}

\subsection{Player Flow}

\begin{enumerate}
    \item Create or join chaos mode game
    \item Play moves normally (if not in chaos mode)
    \item Or watch as spectators vote on moves
    \item Game proceeds with voted moves
    \item Can still resign, offer draw, etc.
\end{enumerate}

\section{Advanced Features}

\subsection{Move Suggestions}

Engine can suggest moves with explanations:

\begin{lstlisting}[language=typescript, caption=Move Suggestions with Explanations]
interface MoveSuggestion {
    move: string;
    notation: string;
    evaluation: number;
    explanation: string;
    variations: Variation[];
}

async function generateMoveSuggestions(
    fen: string,
    depth: number = 15
): Promise<MoveSuggestion[]> {
    const analysis = await chessEngine.analyze(fen, depth);
    
    return analysis.topMoves.map(move => ({
        move: move.san,
        notation: move.san,
        evaluation: move.evaluation,
        explanation: generateExplanation(move),
        variations: move.variations
    }));
}

function generateExplanation(move: MoveAnalysis): string {
    if (move.isCheckmate) return 'Checkmate!';
    if (move.isCheck) return 'Gives check';
    if (move.captures) return `Captures ${move.capturedPiece}`;
    if (move.isTactical) return 'Tactical opportunity';
    return `Improves position by ${move.evaluation} centipawns`;
}
\end{lstlisting}

\subsection{Vote Analytics}

Track voting patterns and statistics:

\begin{itemize}
    \item Most popular move types
    \item Vote distribution over time
    \item User voting behavior
    \item Move success rates (win/loss after voted moves)
    \item Chaos effect frequency
\end{itemize}

\section{Comparison: GTA vs Chess}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|}
        \toprule
        \textbf{Aspect} & \textbf{GTA Chaos Mod} & \textbf{Chess Chaos Mode} \\
        \midrule
        Options & Random effects & Legal chess moves \\
        Validation & None required & Must be legal moves \\
        Impact & Immediate effect & Affects game state \\
        Reversibility & Effects expire & Moves are permanent \\
        Voting Window & Fixed duration & Per move \\
        Result Mode & Majority/Percentage & Majority/Percentage \\
        \bottomrule
    \end{tabular}
    \caption{Comparison of Chaos Mod Systems}
    \label{tab:chaos-comparison}
\end{table}

\section{Conclusion}

The GTA chaos mod architecture provides an excellent foundation for implementing chat voting in chess. The key adaptations required are:

\begin{itemize}
    \item Replace random effects with legal chess moves
    \item Integrate chess notation (SAN) for voting
    \item Validate all moves before execution
    \item Maintain game state consistency
    \item Provide move explanations and evaluations
    \item Support both notation-based and numeric voting
\end{itemize}

This integration creates a unique and engaging chess experience where the community collectively influences game outcomes through democratic voting.
